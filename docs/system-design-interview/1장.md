---
sidebar_position: 1
---

# 1장 - 사용자 수에 따른 규모 확장

## 단일 서버

보통 사이드프로젝트하면 예산의 제약에 의해 설계하게 되는 구조.
사용자 단말(웹이나 앱)이 DNS에 질의해서 IP주소로 요청을 하고 웹 서버 한 대가 HTML, JSON 응답.

## 데이터베이스

보통 사이드프로젝트하면 예산의 제약에 의해 설계하게 되는 구조2.
단일 서버 + DB 서버 추가(EC2 + RDS 조합)

- 관계형 DB: 테이블, 열, 칼럼으로 자료를 표현. 데이터를 관계에 따라 join.
- 비관계형 DB(NoSQL)

  - 용도: 키-값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소
  - 적합한경우: 아주 낮은 응답 지연시간이 필요할 때, 데이터가 비정형일 때, 데이터(JSON, YAML, XML 등)를 직렬화(serialize)/역직렬화(deserialize)만 하면 될 때, 아주 많은 양의 데이터 저장할 때

:::tip 직렬화/역직렬화

단어만 들었을 땐 감이 안오는데 mongoDB를 로깅으로 쓰는 경우를 생각해보자.<br/>
주고받는 JSON을 통째로 직렬화해서 저장하고, 웹에서 보여주고 싶을 때 역직렬화해서 데이터를 가져다쓴다.<br/>
사전적인 의미는 다음과 같다고 한다.

ㅇ 직렬화(Serialization) : 객체를 직렬화하여 전송 가능한 형태로 만드는 것.<br/> (객체들의 데이터를 연속적인 데이터로 변형하여 Stream을 통해 데이터를 읽도록 해주며 주로 객체들을 통째로 파일로 저장,전송하고 싶을 때 주로 사용된다.)

ㅇ 역직렬화(Deserialization) : 직렬화된 파일 등을 역으로 직렬화하여 다시 객체의 형태로 만드는 것.<br/>(저장된 파일을 읽거나 전송된 Stream 데이터를 읽어 원래 객체의 형태로 복원한다.)

:::

## 수직적 규모 확장 vs 수평적 규모 확장

**수직적 규모 확장 == 스케일 업**

- 장: 단순하다, 서버로 유입되는 트래픽의 양이 적을 땐 좋음
- 단: CPU, 메모리를 늘리는데 한계가 있음, 장애에 대한 자동복구(failover) 방안이나 다중화 방안(redundancy)을 제시하지 않음.

**수평적 규모 확장 == 스케일 아웃**

- 로드밸런서
  - 웹 서버와 Private IP로 통신
  - 도입 시 웹 계층은 괜찮은데 데이터 계층이 불안정 이는 데이터베이스 다중화로 해소
- 데이터베이스 다중화
  - 주 데이터베이스 서버, 부 데이터베이스 서버로 나뉘게 되는데 Master에서는 insert, delete, update만 수행하고 Slave에서는 읽기만 수행한다.
  - 보통 Master DB 서버 갯수 < Slave DB 서버 갯수 인데 이건 통상적으로 어플리케이션에서 읽기 연산이 훨씬 많이 일어나기 때문이라고 한다.
  - 안정성(reliability), 가용성(availability) up

## 캐시

- 웹 서버는 데이터가 캐시에 있으면 캐시에서 데이터를 읽고, 없으면 DB 질의를 통해 캐시에 쓰고 해당 데이터 반환
- 읽기 주도형 캐시 전략(read-through caching strategy)
- 고려되어야 할 점: 어떤 상황에 바람직한지(데이터 갱신은 자주x but 참조는 빈번), 어떤 데이터를 캐시에 두어야 하는지(중요 데이터는 여전히 DB), 데이터 만료 정책은 어떻게 되는지(짧으면 디비 넘 많이 읽고 길면 원본과 차이가 많이 나기 때문), 일관성(원본과 캐시 내 사본이 같은지)은 어떻게 유지되는지, 장애에 어떻게 대처할 것인지(캐시 서버 분산), 캐시 메모리는 얼마나 크게 잡을 것인지(overprovision 필요), 데이터 방출 정책은 어떻게 둘 것인지(경우에 맞게 LRU, LFU, FIFO 선택)

## 콘텐츠 전송 네트워크(CDN)

- 고려되어야 할 점: 비용, 적절한 만료 시한 설정, CDN 장애 시 대처방안(원본 서버로부터 직접 가져오도록), 콘텐츠 무효화(invalidation) 방법(오브젝트 versioning을 통해 CDN에서 제거 ex.v2)

## 무상태(stateless) 웹 계층

:::info 무상태란?

한국어로 들으면 무정부 상태 이런게 떠올라서 감이 잘 안온다.<br/>
근데 실제로는 간단하다. 상태정보(사용자 세션 데이터 같은 정보)들을 웹서버에 저장하는 것이 아닌 관계형 DB나 NoSQL같은 지속성 저장소에 보관하고 필요할 때 가져오는 것이다.

:::

## 데이터 센터

- 지리적 라우팅에서의 geoDNS는 사용자의 위치에 따라 도메인 이름을 어떤 IP 주소로 변환할지 결정할 수 있도록 해주는 DNS 서비스이다.
- 기술적 난제: 트래픽 우회, 데이터 동기화(다른 데이터센터에 해당 데이터가 없으면 안되니까 여러 데이터센터에 걸쳐 데이터를 다중화), 테스트와 배포

## 메시지 큐

:::tip 서버간 결합이 느슨해진다?

서버간 결합이 느슨해져서 규모 확장성이 보장되어야 하는 안정적인 애플리케이션 구성<br/>
생산자는 소비자 프로세스가 다운되어 있어도 메시지 발행이 가능하고 소비자는 생산자가 가용한 상태가 아니더라도 메시지 수신이 가능하다는데 이게 어떻게 가능한건지?<br/>
**=> 이건 일을 비동기로 처리하게 되니 이런식으로 표현을 하는 것 같다**

:::

## 로그, 메트릭 그리고 자동화

- 서비스 규모 커져서 운영할 때 좋은 것들..
- metrics: 호스트 단위 메트릭(CPU, 메모리, 디스크 I/O 등), 종합 메트릭(DB 계층 서능, 캐시 계층 성능 등), 핵심 비즈니스 메트릭(GA에서 측정가능한 것들)

## 데이터베이스의 규모 확장

- DB의 scale out은 sharding

:::tip 샤딩이란?

대규모 DB를 샤드라는 작은 단위로 쪼개는 것. 모든 샤드는 같은 스키마를 쓰지만 데이터 간 중복이 없다.
구현 시 고려해야 되는 점은 샤딩 키(파티션 키)를 어떻게 정하느냐.

:::

- 샤딩 시 난제: 데이터의 재샤딩, 유명인사 문제(hotspot key), 조인과 비정규화

:::info DB 비정규화

또또..비정규화같은 어려운말쓴다..<br/>
샤딩을 여러개로 쪼개고 나면 데이터를 조인하기가 어려운데 이때 DB를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 한다.<br/>
**=> 의도적으로 하나 이상의 테이블에 데이터를 중복 배치해 정규화 원칙을 위배하는 행위**<br/>
**=> 예를 들면 다른 테이블에 있는 칼럼을 내가 join 해서 조회해올 수 있지만 여러가지 요인으로 현재 테이블에 그 칼럼이 한번 더 있는게 나은 상황인거지**

:::
